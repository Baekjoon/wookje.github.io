---
layout: post
title: '[BOJ] 2458 : 키 순서'
author: wookje.kwon
comments: true
date: 2017-08-20 00:36
tags: [boj, koi, dfs]

---

[2458 : 키 순서](https://www.acmicpc.net/problem/2458)

## 풀이

모든 노드에서 dfs를 정방향으로 한 번, 역방향으로 한 번 돌려주자!

정방향은 나보다 큰 친구들, 역방향은 나보다 큰 친구들의 개수(?)이다.

이 둘을 합한 값이 나를 제외한 n-1명과 같은지 알아보자!

## 코드

```cpp
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stdlib.h>
using namespace std;

int n, m, vst[2][501];
vector<int> gph[2][501];

int dfs(int num, int now) {
	int ret = 1; vst[num][now] = 1;
	for (int nxt : gph[num][now]) if (!vst[num][nxt]) ret += dfs(num, nxt);
	return ret;
}

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 0; i < m; i++) {
		int u, v;
		scanf("%d %d", &u, &v);
		gph[0][u].push_back(v), gph[1][v].push_back(u);
	}

	int cnt = 0;
	for (int i = 1; i <= n; i++) {
		memset(vst, 0, sizeof(vst));
		if (dfs(0, i) + dfs(1, i) - 1 == n) cnt++;
	}

	printf("%d", cnt);

	return 0;
}
```

### 아무말  
백준, 백준 온라인 저지, BOJ, Baekjoon Online Judge